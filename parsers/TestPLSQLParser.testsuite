/**
 * Oracle(c) PL/SQL 11g Parser
 *
 * Copyright (c) 2009-2011 Alexandre Porcelli <alexandre.porcelli@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

gunit PLSQL;

@header { package br.com.porcelli.parser.plsql; }

compilation_unit:
"" OK

datatype:
"pls_integer" OK
"binary_integer"  OK
"binary_float"  OK
"binary_double"  OK
"number"  OK
"natural"  OK
"naturaln"  OK
"positive"  OK
"positiven"  OK
"signtype"  OK
"simple_integer"  OK
"number(8,2)"  OK
"number(2)"  OK
"dec"  OK
"decimal"  OK
"numeric"  OK
"double precision"  OK
"float"  OK
"int"  OK
"integer"  OK
"smallint"  OK
"char "  OK
"varchar2"  OK
"string"  OK
"raw"  OK
"nchar"  OK
"nvarchar2"  OK
"long"  OK
"long raw"  OK
"rowid"  OK
"urowid"  OK
"char "  OK
"varchar2 "  OK
"char(10 char) "  OK
"varchar2(32 byte)"  OK
"char(4)"  OK
"character"  OK
"varchar2(1999 byte)"  OK
"varchar2(2000 byte)"  OK
"char(10)"  OK
"raw(256)"  OK
"nchar "  OK
"nchar(100)"  OK
"nvarchar2(300)"  OK
"urowid"  OK
"long"  OK
"long raw"  OK
"rowid"  OK
"boolean"  OK
"year"  OK
"month"  OK
"day"  OK
"hour"  OK
"minute"  OK
"second"  OK
"timezone_hour"  OK
"timezone_minute"  OK
"timezone_region"  OK
"timezone_abbr"  OK
"date"  OK
"timestamp(3)"  OK
"timestamp"  OK
"timestamp(3) with time zone"  OK
"timestamp(3) with local time zone"  OK
"timestamp with time zone"  OK
"timestamp with local time zone"  OK
"interval year(3) to month "  OK
"interval year to month "   OK
"interval day(3) to second(3)" OK
"interval day to second(3)"  OK
"timestamp_unconstrained"  OK
"timestamp_tz_unconstrained"  OK
"timestamp_ltz_unconstrained"  OK
"yminterval_unconstrained"  OK
"dsinterval_unconstrained"  OK
"bfile"  OK
"blob"  OK
"clob"  OK
"nclob"  OK

declare_spec:
"dept_names dnames_tab := dnames_tab('Shipping','Sales','Finance','Payroll');" OK
"credit_limit      constant real    := 5000.00;" OK
"max_days_in_year  constant integer := 366;" OK
"urban_legend      constant boolean := false;" OK
"blood_type char default 'o';" OK
"hours_worked    integer default 40;" OK
"acct_id integer(4) not null := 9999 ;" OK
"part_number       number(6);" OK
"part_name         varchar2(20); " OK
"in_stock          boolean; " OK
"part_price        number(6,2); " OK
"part_description  varchar2(50);" OK
"hours_worked   number := 40; " OK
"emp_rec2       employees%rowtype;" OK
"valid_id       boolean;" OK
"country        varchar2(128); " OK
"hourly_salary  number := 22.50;" OK
"bonus   number(8,2);" OK
"v_last_name employees.last_name%type;" OK
"dept_rec departments%ROWTYPE; -- declare record variable" OK
"staff  staff_list;" OK
"empid      employees.employee_id%type := 115;" OK
"subtype birthdate is date not null;         -- Based on DATE type " OK
"subtype counter is natural;                 -- Based on NATURAL subtype " OK
"subtype finishtime is timerec;                -- Based on RECORD type " OK
"subtype id_num is employees.employee_id%type; -- Based on column type" OK
"subtype counter is natural;" OK
"subtype v_empid_subtype    is employees_temp.empid%type;" OK
"cursor c1 is select employee_id.* from employees where salary > 2000;" OK
<<cursor c1 (low  number default 0, high number default 99) is
           select employee_id.* from departments where department_id > low
           and department_id < high;>> OK
<<cursor c2 return departments%rowtype is
      select employee_id.* from departments where department_id = 110;>> OK
"past_due exception;" OK
"a.past_due exception;" OK
"pragma serially_reusable;" OK
"pragma autonomous_transaction;" OK
"pragma exception_init(deadlock_detected, 60);" OK
"pragma exception_init(null_salary, 20101);" OK
"pragma restrict_references (credit_ok, wnds, rnps);" OK
"pragma restrict_references (log_msg, wnds, rnds);" OK
"pragma inline (identifier, 'yes');" OK
"type tmpcurtyp is ref cursor return employees%rowtype; " OK
"type empcurtyp is ref cursor return tmp_cv%rowtype; " OK
"type deptcurtyp is ref cursor return dept_rec%type; " OK
"type empcurtyp is ref cursor return emprectyp; " OK
"type empcurtyp is ref cursor return employees%rowtype;" OK
<<type emprectyp is record (
     employee_id number,
     last_name varchar2(25),
     salary   number(8,2)); >> OK
"type empcurtyp is ref cursor return employees%rowtype;" OK
"type genericcurtyp is ref cursor;" OK
<<type timerec is record (
  hours   smallint,
  minutes smallint
);>>  OK
<<type meeting_type is record (
  date_held  date,
  duration   timerec,  -- nested record
  location   varchar2(20),
  purpose    varchar2(50)
);>>  OK
<<type deptrectyp is record (
    deptid number(4) not null := 99,
    dname  departments.department_name%type,
    loc    departments.location_id%type,
    region regions%rowtype );>> OK
"type rec1_t is record (field1 varchar2(16), field2 number, field3 date);" OK
<<type rec2_t is record (id integer not null := -1,
 name varchar2(64) not null := '[anonymous]');>> OK
<<type rec4_t is record (first_name employees.first_name%type,
                        last_name employees.last_name%type,
                        rating number);>> OK
<<type meetingtyp is record (
    day     date,
    time_of timetyp,             -- nested record
    dept    departments%rowtype,
      -- nested record representing a table row
    place   varchar2(20),
    purpose varchar2(50) );>> OK
<<type recordtyp is record (last employees.last_name%type,
                           id employees.employee_id%type);>> OK
"type staff_list is table of employees.employee_id%type;" OK
<<type population is table of number  -- associative array type
  index by varchar2(64);>> OK
"type calendar is varray(366) of date;" OK
<<type emptabtyp is table of employees%rowtype
      index by pls_integer;>> OK
<<type assoc_array_num_type
   is table of number index by pls_integer; >> OK
<<type assoc_array_str_type
   is table of varchar2(32) index by pls_integer; >> OK
<<type assoc_array_str_type2
   is table of varchar2(32) index by varchar2(64);>> OK
"type nested_type is table of varchar2(30); " OK
"type varray_type is varray(5) of integer; " OK
"type few_depts  is varray(10)  of varchar2(30); " OK
"type many_depts is varray(100) of varchar2(64);" OK
"type staff_list is table of employees.employee_id%type;" OK
"type emplist is table of employees.employee_id%type;" OK
"type senior_salespeople is varray(10) of employees%rowtype;" OK
"type namelist is varray(20) of c2%rowtype;" OK
"type dnames_tab is table of varchar2(30);" OK
"type dnames_var is varray(20) of varchar2(30);" OK
"type dnames_tab is table of varchar2(30);" OK
"type dnamesnonulls_type is table of varchar2(30) not null;" OK
"type sum_multiples is table of pls_integer index by pls_integer;" OK
"type last_name_typ is varray(3) of varchar2(64); " OK
"type surname_typ is varray(3) of varchar2(64);" OK
"type t1 is varray(10) of integer; " OK
"type nt1 is varray(10) of t1; -- multilevel varray type" OK
"type tb1 is table of varchar2(20); " OK
"type ntb1 is table of tb1; -- table of table elements" OK
"type tv1 is varray(10) of integer; " OK
"type ntb2 is table of tv1; -- table of varray elements" OK
"type tb1 is table of integer index by pls_integer; " OK
"type ntb1 is table of tb1 index by pls_integer; " OK
"type va1 is varray(10) of varchar2(20); " OK
"type ntb2 is table of va1 index by pls_integer; " OK
<<create procedure remove_emp (employee_id number) as
   tot_emps number;
   begin
    null;
   end;>> OK
<<create procedure increase_comm(employee_id number, comm_incr number) is
   type va1 is varray(10) of varchar2(20);
   curr_comm number;
   begin
      null;
   end;>> OK
<<create procedure find_root
   ( x in real )
   is language java
      name 'osl.test.Run';>>  OK
<<create procedure find_root
   ( x in real )
   as language c
      name 'c_get_val'
      library c_utils
      parameters (...);>> OK
<<create procedure find_root
   ( x in real )
   as language c
      name 'c_get_val'
      library c_utils
      parameters (a, b, c);>> OK
<<create function get_bal(acc_no in number)
   return number
   is acc_bal number(11,2);
   begin
    null;
    end;>> OK
<<create function get_val
   ( x_val in number,
    y_val in number,
    image in long raw )
   return binary_integer as language java name 'teste'; >> OK
<<create or replace function text_length(a clob)
   return number deterministic is
begin
  null;
end; >> OK

variable_declaration:
"dept_names dnames_tab := dnames_tab('Shipping','Sales','Finance','Payroll');" OK
"credit_limit      constant real    := 5000.00;" OK
"max_days_in_year  constant integer := 366;" OK
"urban_legend      constant boolean := false;" OK
"blood_type char default 'o';" OK
"hours_worked    integer default 40;" OK
"acct_id integer(4) not null := 9999 ;" OK
"part_number       number(6);" OK
"part_name         varchar2(20); " OK
"in_stock          boolean; " OK
"part_price        number(6,2); " OK
"part_description  varchar2(50);" OK
"hours_worked   number := 40; " OK
"emp_rec2       employees%rowtype;" OK
"valid_id       boolean;" OK
"country        varchar2(128); " OK
"hourly_salary  number := 22.50;" OK
"bonus   number(8,2);" OK
"v_last_name employees.last_name%type;" OK
"dept_rec departments%ROWTYPE; -- declare record variable" OK
"staff  staff_list;" OK
"empid      employees.employee_id%type := 115;" OK

subtype_declaration:
"subtype birthdate is date not null;         -- Based on DATE type " OK
"subtype counter is natural;                 -- Based on NATURAL subtype " OK
"subtype finishtime is timerec;                -- Based on RECORD type " OK
"subtype id_num is employees.employee_id%type; -- Based on column type" OK
"subtype counter is natural;" OK
"subtype v_empid_subtype    is employees_temp.empid%type;" OK
"subtype v_empid_subtype    is numeric(2) range 1 .. 80;" OK

cursor_declaration:
"cursor c1 is select employee_id.* from employees where salary > 2000;" OK
<<cursor c1 (low  number default 0, high number default 99) is
           select employee_id.* from departments where department_id > low
           and department_id < high;>> OK
<<cursor c2 return departments%rowtype is
      select employee_id.* from departments where department_id = 110;>> OK

exception_declaration:
"past_due exception;" OK
"a.past_due exception;" OK

pragma_declaration:
"pragma serially_reusable;" OK
"pragma autonomous_transaction;" OK
"pragma exception_init(deadlock_detected, 60);" OK
"pragma exception_init(null_salary, 20101);" OK
"pragma restrict_references (credit_ok, wnds, rnps);" OK
"pragma restrict_references (log_msg, wnds, rnds);" OK
"pragma inline (identifier, 'yes');" OK
"pragma exception_init (duplicate_info, 00001);" OK

record_declaration:
"type tmpcurtyp is ref cursor return employees%rowtype; " OK
"type empcurtyp is ref cursor return tmp_cv%rowtype; " OK
"type deptcurtyp is ref cursor return dept_rec%type; " OK
"type empcurtyp is ref cursor return emprectyp; " OK
"type empcurtyp is ref cursor return employees%rowtype;" OK
<<type emprectyp is record (
     employee_id number,
     last_name varchar2(25),
     salary   number(8,2)); >> OK
"type empcurtyp is ref cursor return employees%rowtype;" OK
"type genericcurtyp is ref cursor;" OK
<<type timerec is record (
  hours   smallint,
  minutes smallint
);>>  OK
<<type meeting_type is record (
  date_held  date,
  duration   timerec,  -- nested record
  location   varchar2(20),
  purpose    varchar2(50)
);>>  OK
<<type deptrectyp is record (
    deptid number(4) not null := 99,
    dname  departments.department_name%type,
    loc    departments.location_id%type,
    region regions%rowtype );>> OK
"type rec1_t is record (field1 varchar2(16), field2 number, field3 date);" OK
<<type rec2_t is record (id integer not null := -1,
 name varchar2(64) not null := '[anonymous]');>> OK
<<type rec4_t is record (first_name employees.first_name%type,
                        last_name employees.last_name%type,
                        rating number);>> OK
<<type meetingtyp is record (
    day     date,
    time_of timetyp,             -- nested record
    dept    departments%rowtype,
      -- nested record representing a table row
    place   varchar2(20),
    purpose varchar2(50) );>> OK
<<type recordtyp is record (last employees.last_name%type,
                           id employees.employee_id%type);>> OK

table_declaration:
"type staff_list is table of employees.employee_id%type;" OK
<<type population is table of number  -- associative array type
  index by varchar2(64);>> OK
"type calendar is varray(366) of date;" OK
<<type emptabtyp is table of employees%rowtype
      index by pls_integer;>> OK
<<type assoc_array_num_type
   is table of number index by pls_integer; >> OK
<<type assoc_array_str_type
   is table of varchar2(32) index by pls_integer; >> OK
<<type assoc_array_str_type2
   is table of varchar2(32) index by varchar2(64);>> OK
"type nested_type is table of varchar2(30); " OK
"type varray_type is varray(5) of integer; " OK
"type few_depts  is varray(10)  of varchar2(30); " OK
"type many_depts is varray(100) of varchar2(64);" OK
"type staff_list is table of employees.employee_id%type;" OK
"type emplist is table of employees.employee_id%type;" OK
"type senior_salespeople is varray(10) of employees%rowtype;" OK
"type namelist is varray(20) of c2%rowtype;" OK
"type dnames_tab is table of varchar2(30);" OK
"type dnames_var is varray(20) of varchar2(30);" OK
"type dnames_tab is table of varchar2(30);" OK
"type dnamesnonulls_type is table of varchar2(30) not null;" OK
"type sum_multiples is table of pls_integer index by pls_integer;" OK
"type last_name_typ is varray(3) of varchar2(64); " OK
"type surname_typ is varray(3) of varchar2(64);" OK
"type t1 is varray(10) of integer; " OK
"type nt1 is varray(10) of t1; -- multilevel varray type" OK
"type tb1 is table of varchar2(20); " OK
"type ntb1 is table of tb1; -- table of table elements" OK
"type tv1 is varray(10) of integer; " OK
"type ntb2 is table of tv1; -- table of varray elements" OK
"type tb1 is table of integer index by pls_integer; " OK
"type ntb1 is table of tb1 index by pls_integer; " OK
"type va1 is varray(10) of varchar2(20); " OK
"type ntb2 is table of va1 index by pls_integer; " OK

create_procedure_body:
<<create procedure remove_emp (employee_id number) as
   tot_emps number;
   begin
    null;
   end;>> OK
<<create procedure increase_comm(employee_id number, comm_incr number) is
   type va1 is varray(10) of varchar2(20);
   curr_comm number;
   begin
      null;
   end;>> OK
<<create procedure find_root
   ( x in real )
   is language java
      name 'osl.test.Run';>>  OK

create_function_body:
"create function secondmax (input number) return number deterministic result_cache relies_on (product_descriptions) parallel_enable authid current_user aggregate using secondmaximpl;" OK
"create function secondmax (input number) return number parallel_enable authid definer aggregate using secondmaximpl;" OK
"create function secondmax (input number) return number parallel_enable aggregate using secondmaximpl;" OK
"function all_product_names (lang_id number) return product_names result_cache relies_on (product_descriptions) aggregate using secondmaximpl;"  OK
<<create function secondmax (input number)
    return number
    result_cache relies_on (product_descriptions)
    parallel_enable ( partition teste_here by any )
    aggregate using secondmaximpl;>> OK
<<create function secondmax (input number)
    return number
    result_cache
    parallel_enable ( partition teste_here by hash (a, b) )
    aggregate using secondmaximpl;>> OK
<<create function secondmax (input number)
    return number
    parallel_enable ( partition teste_here by hash (a, b) order teste_xx by (a,b) )
    aggregate using secondmaximpl;>> OK
<<create function secondmax (input number)
    return number
    parallel_enable ( partition teste_here by hash (a, b) cluster teste_xx by (a,b) )
    aggregate using secondmaximpl;>> OK
<<create function secondmax (input number)
    return number
    parallel_enable ( partition teste_here by range (a, b) cluster teste_xx by (a,b) )
    aggregate using secondmaximpl;>> OK
<<create function get_bal(acc_no in number)
   return number
   is acc_bal number(11,2);
   begin
    null;
    end;>> OK

<<create function get_val
   ( x_val in number,
    y_val in number,
    image in long raw )
   return binary_integer as language java name 'teste'; >> OK

<<create or replace function text_length(a clob)
   return number deterministic is
begin
  null;
end; >> OK

create_package:
<<create or replace package emp_mgmt as
   function hire (last_name varchar2, job_id varchar2,
      manager_id number, salary number,
      commission_pct number, department_id number)
      return number;
   function create_dept(department_id number, location_id number)
      return number;
   procedure remove_emp(employee_id number);
   procedure remove_dept(department_id number);
   procedure increase_sal(employee_id number, salary_incr number);
   procedure increase_comm(employee_id number, comm_incr number);
   no_comm exception;
   no_sal exception;
end emp_mgmt;>> OK
<<create package trans_data as  -- bodiless package
   type timerec is record (
      minutes smallint,
      hours   smallint);
   type transrec is record (
      category varchar2(10),
      account  int,
      amount   real,
      time_of  timerec);
   minimum_balance    constant real := 10.00;
   number_processed   int;
   insufficient_funds exception;
end trans_data;>> OK
<<create package emp_bonus as
   procedure calc_bonus (date_hired employees.hire_date%type);
end emp_bonus; >> OK
<<create or replace package emp_admin as
-- declare externally visible types, cursor, exception
   type emprectyp is record (emp_id number, sal number);
   cursor desc_salary return emprectyp;
   invalid_salary exception;
-- declare externally callable subprograms
   function hire_employee (last_name varchar2,
                           first_name varchar2,
                           email varchar2,
                           phone_number varchar2,
                           job_id varchar2,
                           salary number,
                           commission_pct number,
                           manager_id number,
                           department_id number)
     return number;
   procedure fire_employee
     (emp_id number); -- overloaded subprogram
   procedure fire_employee
     (emp_email varchar2); -- overloaded subprogram
   procedure raise_salary (emp_id number, amount number);
   function nth_highest_salary (n number) return emprectyp;
end emp_admin;>> OK
<<create package emp_stuff as
  -- declare cursor spec
  cursor c1 return employees%rowtype;
end emp_stuff;>> OK
<<create or replace package body emp_mgmt as
   tot_emps number;
   tot_depts number;
function hire
   (last_name varchar2, job_id varchar2,
    manager_id number, salary number,
    commission_pct number, department_id number)
   return number is new_empno number;
begin
   null;
end;
function create_dept(department_id number, location_id number)
   return number is
      new_deptno number;
   begin
      null;
   end;
procedure remove_emp (employee_id number) is
   begin
      null;
   end;
procedure remove_dept(department_id number) is
   begin
         null;
   end;
procedure increase_sal(employee_id number, salary_incr number) is
   curr_sal number;
   begin
      null;
   end;
procedure increase_comm(employee_id number, comm_incr number) is
   curr_comm number;
   begin
    null;
   end;
end emp_mgmt;>> OK

statement:
<<case grade
  when 'a' then null;
  when 'b' then null;
  when 'c' then null;
  when 'd' then null;
  when 'f' then null;
  else null;
end case>> OK
<<case
  when grade = 'a' then null;
  when grade = 'b' then null;
  when grade = 'c' then null;
  when grade = 'd' then null;
  when grade = 'f' then null;
  else null;
end case>> OK
<<case
  when grade = 'a' then null;
  when grade = 'b' then null;
  when grade = 'c' then null;
  when grade = 'd' then null;
  when grade = 'f' then null;
end case>> OK
<<case
  when jobid = 'pu_clerk' then
    if sal < 3000 then
      null;
    else
      null;
    end if;
  when jobid = 'sh_clerk' then
    if sal < 4000 then
      null;
    else
      null;
    end if;
  when jobid = 'st_clerk' then
    if sal < 3500 then
      null;
    else
      null;
    end if;
  else
    null;
end case>> OK

continue_statement:
"continue" OK
"continue when x < 3" OK
"continue label_name" OK
"continue label_name when x < 3" OK

exit_statement:
"exit" OK
"exit when x < 3" OK
"exit label_name" OK
"exit label_name when x < 3" OK

goto_statement:
"goto print_now" OK

raise_statement:
"raise" OK
"raise exception_name" OK

return_statement:
"return emp_rec" OK
"return emp_rec" OK
"return sal >= min_sal" OK
"return (sal >= min_sal) and (sal <= max_sal)" OK

if_statement:
<<if sales0 = 50000 then
  null;
elsif sales1 = 35000 then
  null;
else
  null;
end if>> OK
<<if grade = 'a' then
  null;
elsif grade = 'b' then
  null;
elsif grade = 'c' then
  null;
elsif grade = 'd' then
  null;
elsif grade = 'f' then
  null;
else
  null;
end if>> OK
<<if sales > quota then
  null;
else
  if sales > quota then
    null;
  else
    null;
  end if;
end if>> OK

loop_statement:
<<for i in 1 .. 10 loop
  -- process data here
  for j in 1 .. 10 loop
    null;
    -- process data here
  end loop;
end loop outer_loop>> OK
<<for i in reverse 1 .. 10 loop  -- i starts at 10, ends at 1
   dbms_output.put_line(i); -- statements here execute 10 times
  end loop>> OK
<<while not done loop
  null;
end loop>> OK
<<while condition loop
  null;
end loop>> OK
<<for x in c1 (a, b, c) loop
null;
end loop>> OK
<<for x in c1 loop
null;
end loop>> OK

<<for i in 1..10 loop
  for j in 1..10 loop
    null;
  end loop;
end loop outer_loop>> OK

forall_statement:
<<forall j in 4 .. 7
      select employee_id.* from employees where deptsxx = 200>> OK
<<forall i in indices of cust_tab
     select employee_id.* from employees where deptsxx = 200>> OK
<<forall i in indices of cust_tab between 1 and 10
     select employee_id.* from employees where deptsxx = 200>> OK
<<forall i in values of rejected_order_tab
   select employee_id.* from employees where deptsxx = 200>> OK
<<forall i in values of big_order_tab
   select employee_id.* from employees where deptsxx = 200>> OK
<<forall j in depts.first..depts.last
   select employee_id.* from employees where deptsxx = 200>> OK
<<forall i in indices of cust_tab between 1 and 10
     select employee_id.* from employees where deptsxx = 200 save exceptions>> OK

<<forall j in 4..7
      select employee_id.* from employees where deptsxx = 200>> OK

close_statement:
"close c1"  OK
"close :c1" OK
"close :c1_teste" OK

fetch_statement:
"fetch c2 into v_employees" OK
"fetch c1 into v_lastname, v_jobid" OK
"fetch c1 bulk collect into ids, names" OK
"fetch emp_cv bulk collect into names, sals" OK
"fetch c1 bulk collect into :ids" OK

open_statement:
"open c1" OK
"open c1(a,b,c)" OK
"open c1()" OK

rollback_statement:
"rollback" OK
"rollback to savepoint banda_sal" OK
"rollback work force '25.32.87'" OK

savepoint_statement:
"savepoint banda_sal" OK

alter_function:
"alter function oe.get_bal compile;" OK

set_transaction_command:
"set transaction read only name 'toronto'" OK
"set transaction read only name 'toronto'" OK
"set transaction read write name 'toronto'" OK
"set transaction name 'toronto'" OK

commit_statement:
"commit work"  OK
"commit write batch"  OK
"commit comment 'in-doubt transaction code 36, call (415) 555-2637'"  OK
"commit force '22.57.53'" OK

lock_table_statement:
<<lock table employees
   in exclusive mode
   nowait>>  OK
<<lock table employees
   in exclusive mode
   wait 10>>  OK
<<lock table employees
   in share update mode
   wait 10>>  OK
<<lock table employees
   in share mode
   wait 10>>  OK
<<lock table employees
   in row share mode
   wait 10>>  OK
<<lock table a.employees
   in row share mode
   wait 10>>  OK
<<lock table a.employees@teste partition for (1, 2)
   in row share mode
   wait 10>> OK
<<lock table a.employees@teste partition (1)
   in row share mode
   wait 10>> OK
<<lock table a.employees@teste subpartition for (1, 2)
   in row share mode
   wait 10>> OK
<<lock table a.employees@teste subpartition (1)
   in row share mode
   wait 10>> OK

merge_statement:
<<merge into bonuses d
   using (select employee_id.* from employees) s
   on (employee_id = a)
   when matched then update set d.bonus = bonus
     delete where (salary > 8000)
   when not matched then insert (d.employee_id, d.bonus)
     values (s.employee_id, s.salary)
     where (s.salary <= 8000)>> OK
<<merge into bonuses d
   using (select employee_id.* from employees) s
   on (employee_id = a)
   when matched then update set d.bonus = bonus
     delete where (salary > 8000)
   when not matched then insert (d.employee_id, d.bonus)
     values (s.employee_id, s.salary)
     where (s.salary <= 8000)
   log errors into errlog ('my_bad') reject limit 10>> OK

exception_handler:
"when invalid_number or standard.invalid_number then null;"  OK
"when invalid_number then null;"  OK

execute_immediate:
"execute immediate anything using in out new_deptid, new_dname, new_mgrid, new_locid"  OK
"execute immediate dyn_stmt using in b1"  OK
"execute immediate dyn_stmt using in out b1"  OK
"execute immediate dyn_stmt using out b1"  OK
"execute immediate 'update employees_temp set commission_pct = :x' using a_null"  OK
"execute immediate dyn_stmt returning into x"  OK

set_constraint_command:
"set constraints all immediate"  OK
"set constraints emp_job_nn, emp_salary_min, hr.jhist_dept_fk@remote deferred"  OK

function_call:
<<raise_application_error (
         num=> 20107,
         msg=> 'duplicate customer or order id')>>  OK

open_for_statement:
"open :emp_cv for select employee_id.* from employees" OK
"open v_emp_cursor for v_stmt_str using 'manager'" OK
"open v_emp_cursor for 'select employee_id.* from employees' using 'manager'" OK
"open c1 for with t1 as ( select a ,b from t2 where d = 1 ) select a,b from t1" OK

create_trigger:
<<create trigger schema.trigger_name
    before
    delete or insert or update
    on schema.table_name
       begin null; end;>>  OK
<<create trigger hr.salary_check
      before insert or update of salary, job_id on hr.employees
      for each row
         when (job_id = a)
      begin null; end;>>  OK
<<create trigger audit_db_object after create
   on schema
      begin null; end;>>  OK
<<create trigger salary_check
   before insert or update of salary, job_id on employees
   for each row
   when (a = b)
   call check_sal(:job_id, :salary, :last_name);>> OK
<<create trigger log_errors after servererror on database
   begin null; end;>>  OK
<<create or replace trigger order_info_insert
   instead of insert on order_info
   declare
     duplicate_info exception;
     pragma exception_init (duplicate_info, 00001);
   begin
     null;
   exception
     when duplicate_info then
       null;
   end order_info_insert;>> OK
<<create or replace trigger order_info_insert
   instead of insert on order_info
   declare
     duplicate_info exception;
     pragma exception_init (duplicate_info, 00001);
   begin
     null;
   exception
     when duplicate_info then
       null;
   end order_info_insert;>>  OK
<<create or replace trigger order_info_insert
   instead of insert on order_info
   declare
     duplicate_info exception;
     pragma exception_init (duplicate_info, 00001);
   begin
     null;
   exception
     when duplicate_info then
       null;
   end order_info_insert; >> OK
<<create or replace trigger drop_trigger
   before drop on hr.schema
   begin
      null;
   end;>> OK
<<create or replace trigger dept_emplist_tr
  instead of insert on nested table emplist of dept_view
    referencing new as employee
      parent as department
        for each row
begin
  -- insert on nested table translates to insert on base table:
  null;
end;>> OK
<<create or replace trigger manager_info_insert
  instead of insert on manager_info
    referencing new as n  -- new manager information
      for each row
declare
  rowcnt number;
begin null; end;>> OK
<<create or replace trigger log_salary_increase
  after update on emp
    for each row
      when (new.sal > 1000)
    begin null; end;>> OK
<<create or replace trigger log_emp_update
  after update on emp
begin
  null;
end;>> OK
<<create or replace trigger compound_trigger
   for update of salary on employees
     compound trigger

   -- declarative part (optional)
   -- variables declared here have firing-statement duration.
   threshold constant simple_integer := 200;

   before statement is
   begin
     null;
   end before statement;

   before each row is
   begin
     null;
   end before each row;

   after each row is
   begin
     null;
   end after each row;

   after statement is
   begin
     null;
   end after statement;
 end compound_trigger;>> OK
 <<create or replace trigger maintain_employee_salaries
  for update of salary on employees
    compound trigger
    -- declarative part:
    -- choose small threshhold value to show how example works:
      threshhold constant simple_integer := 7;
      type salaries_t is table of employee_salaries%rowtype index by simple_integer;
      salaries  salaries_t;
      idx       simple_integer := 0;
      procedure flush_array is
        n constant simple_integer := salaries.count();
      begin
        null;
      end flush_array;
      -- after each row section:
      after each row is
      begin
        null;
      end after each row;
      -- after statement section:
      after statement is
      begin
        null;
      end after statement;
    end maintain_employee_salaries;>>  OK
<<create or replace trigger check_employee_salary_raise
  for update of salary on employees
compound trigger
  ten_percent                 constant number := 0.1;
  type salaries_t             is table of employees.salary%type;
  avg_salaries                salaries_t;
  type department_ids_t       is table of employees.department_id%type;
  department_ids              department_ids_t;
  type department_salaries_t  is table of employees.salary%type
                                index by varchar2(80);
  department_avg_salaries     department_salaries_t;
  before statement is
  begin
    null;
  end before statement;
  after each row is
  begin
    null;
  end after each row;
end check_employee_salary_raise;>> OK
<<create or replace trigger pre_del_trigger before delete on tab
for each row
call before_delete (:id, :ename);>> OK
<<create or replace trigger trg1
  before update on tab1
  for each row
begin
    null;
end;>>  OK
<<create or replace trigger print_salary_changes
before update on new
referencing new as newest
for each row
begin
   null;
end; >> OK
<<create or replace trigger example
  after insert on emp
    for each row
begin
  null;
exception
  when others then
    null;
end;>>  OK
<<create or replace trigger example
  after insert on emp
    for each row
begin
  insert_row_proc;
end;>>  OK
<<create or replace trigger emp_count
  after delete on emp
    for each row
declare
  n integer;
begin
  null;
end;>> OK
<<create trigger pt after update on p for each row begin
  null;
end; >>  OK
<<create or replace trigger my_trigger after create on database
begin null;
end;>> OK
<<create or replace trigger reorder
after update of parts_on_hand on inventory
for each row
when(parts_on_hand < b)
declare
   x number;
begin
   null;
end;>>  OK
<<create or replace trigger emp_dept_check
  before insert or update of deptno on emp
    for each row when (new.deptno is not null)
  -- before row is inserted or deptno is updated in emp table,
  -- fire this trigger to verify that new foreign key value (deptno)
  -- is present in dept table.
declare
  dummy              integer;  -- use for cursor fetch
  invalid_department exception;
  valid_department   exception;
  mutating_table     exception;
  pragma exception_init (mutating_table, 4091);
  -- cursor used to verify parent key value exists.
  -- if present, lock parent key's row so it cannot be deleted
  -- by another transaction until this transaction is
  -- committed or rolled back.
begin
  -- verify parent key.
  -- if not found, raise user-specified error number & message.
  -- if found, close cursor before allowing triggering statement to complete:
  null;
exception
  when invalid_department then
    null;
  when valid_department then
    null;
  when mutating_table then
    null;
end; >>  OK
<<create or replace trigger dept_set_null
  after delete or update of deptno on dept
    for each row
-- before row is deleted from dept or primary key (deptno) of dept is updated,
-- set all corresponding dependent foreign key values in emp to null:
begin null; end;>>  OK
<<create or replace trigger dept_del_cascade
  after delete on dept
    for each row
-- before row is deleted from dept,
-- delete all rows from emp table whose deptno is same as
-- deptno being deleted from dept table:
begin
  null;
end; >>  OK
<<create or replace trigger dept_cascade3 after update of deptno on dept
begin null;
end;>>  OK
<<create or replace trigger salary_check
  before insert or update of sal, job on emp99
    for each row
declare
  minsal               number;
  maxsal               number;
  salary_out_of_range  exception;
begin null; end;>>  OK
<<create or replace trigger derived
before insert or update of ename on emp99
/* before updating the ename field, derive the values for
   the uppername and soundexname fields. restrict users
   from updating these fields directly: */
for each row
begin
   null;
end;>> OK
<<create or replace trigger library_trigger instead of insert on library_view for
each row
   bookvar book_t;
   i       integer;
begin
   null;
end;>> OK

alter_trigger:
"alter trigger update_job_history enable;"  OK
"alter trigger update_job_history disable;"  OK
"alter trigger update_job_history rename to xxx;"  OK
"alter trigger update_job_history compile;" OK
"alter trigger update_job_history compile debug;"  OK
"alter trigger update_job_history compile debug reuse settings;"  OK
"alter trigger update_job_history compile reuse settings;"  OK
"alter trigger update_job_history compile plsql_optimize_level = 11 plsql_debug = true;"  OK

create_type:
<<create type customer_typ_demo as object
    ( customer_id        number(6)
    , cust_first_name    varchar2(20)
    , cust_last_name     varchar2(20)
    , cust_address       cust_address_typ
    , phone_numbers      phone_list_typ
    , nls_language       varchar2(3)
    , nls_territory      varchar2(30)
    , credit_limit       number(9,2)
    , cust_email         varchar2(30)
    , cust_orders        order_list_typ
    ) ;>> OK
<<create type data_typ1 as object
   ( year number,
     member function prod(invent number) return number
   );>> OK
<<create type corporate_customer_typ_demo under customer_typ
    ( account_mgr_id     number(6)
    );>> OK
<<create type address_t as object
  external name 'examples.address' language java
  using sqldata (
    street_attr varchar(250) external name 'street',
    city_attr varchar(50) external name 'city',
    state varchar(50) external name 'state',
    zip_code_attr number external name 'zipcode',
    static function recom_width return number
      external variable name 'recommendedwidth',
    static function create_address return address_t
      external name 'create() return examples.address',
    static function construct return address_t
      external name 'create() return examples.address',
    static function create_address (street varchar, city varchar,
        state varchar, zip number) return address_t
      external name 'create (java.lang.string, java.lang.string, java.lang.string, int) return examples.address',
    static function construct (street varchar, city varchar,
        state varchar, zip number) return address_t
     external name
        'create (java.lang.string, java.lang.string, java.lang.string, int) return examples.address',
    member function to_string return varchar
      external name 'tojava.lang.string() return java.lang.string',
    member function strip return self as result
      external name 'removeleadingblanks () return examples.address'
  ) not final;>> OK
<<create type person_t as object (name varchar2(100), ssn number)
   not final; >>  OK
"create type part_time_emp_t under employee_t (num_hrs number);" OK
"create type phone_list_typ_demo as varray(5) of varchar2(25);"  OK
<<create type textdoc_typ as object
    ( document_typ      varchar2(32)
    , formatted_doc     blob
    ) ; >> OK
<<create type cust_address_typ2 as object
       ( street_address     varchar2(40)
       , postal_code        varchar2(10)
       , city               varchar2(30)
       , state_province     varchar2(10)
       , country_id         char(2)
       , phone              phone_list_typ_demo
       );>>  OK
<<create type cust_nt_address_typ
   as table of cust_address_typ2;>>  OK
"create type demo_typ1 as object (a1 number, a2 number);"  OK
<<create type demo_typ2 as object (a1 number,
   member function get_square return number);>> OK
<<create or replace type department_t as object (
   deptno number(10),
   dname char(30));>>  OK
<<create or replace type employee_t as object(
   empid raw(16),
   ename char(31),
   dept ref department_t,
      static function construct_emp
      (name varchar2, dept ref department_t)
      return employee_t
);>> OK
<<create or replace type long_address_t
under address_t
external name 'examples.longaddress' language java
using sqldata(
    street2_attr varchar(250) external name 'street2',
    country_attr varchar (200) external name 'country',
    address_code_attr varchar (50) external name 'addrcode',
    static function create_address return long_address_t
      external name 'create() return examples.longaddress',
    static function  construct (street varchar, city varchar,
        state varchar, country varchar, addrs_cd varchar)
      return long_address_t
      external name
        'create(java.lang.string, java.lang.string, java.lang.string, java.lang.string, java.lang.string) return examples.longaddress',
    static function construct return long_address_t
      external name 'examples.longaddress()
        return examples.longaddress',
    static function create_longaddress (
      street varchar, city varchar, state varchar, country varchar,
      addrs_cd varchar) return long_address_t
      external name
        'examples.longaddress (java.lang.string, java.lang.string,
         java.lang.string, java.lang.string, java.lang.string)
           return examples.longaddress',
    member function get_country return varchar
      external name 'country_with_code () return java.lang.string'
  ); >>  OK
<<create type body data_typ1 is
      member function prod (invent number) return number is
         begin
             null;
         end;
      end;>>  OK
<<create type body demo_typ2 is
   member function get_square
   return number
   is x number;
   begin
      null;
   end;
end;>>  OK
<<create or replace type body employee_t is
   static function construct_emp
   (name varchar2, dept ref department_t)
   return employee_t is
      begin
         null;
      end;
end; >>  OK

alter_type:
<<alter type data_typ1
   add member function qtr(der_qtr date)
   return char cascade;>>  OK
<<alter type textdoc_typ
   add attribute (author varchar2) cascade;>>  OK
<<alter type phone_list_typ_demo
  modify limit 10 cascade;>> OK
<<alter type phone_list_typ
  modify element type varchar(64) cascade;>>  OK
"alter type cust_address_typ2 compile;" OK
"alter type link1 add attribute (b number) invalidate;" OK
"alter type link2 compile specification;" OK
"alter type link2 compile body;" OK
"alter type link2 compile;" OK


//DML START

group_by_clause:
"group by country_name,prod_name,calendar_year" OK

select_statement:
"select * from tablex, tabley" OK
<<with
   dept_costs as (
      select department_name, salary dept_total
         from employees e, departments d
         where e.department_id = d.department_id
      group by department_name),
   avg_cost as (
      select dept_total avg
      from dept_costs)
select * from dept_costs
   where dept_total = 10>>  OK
<<select a.b().c('a').getData(getData(1, 22)).xxx
   from employees
   where department_id = 30
   order by last_name>> OK
<<select *
   from employees
   where department_id = 30
   order by last_name>> OK
<<select last_name, job_id, salary, department_id
   from employees
   where job_id = 'pu_clerk'
   order by last_name>>  OK
<<select a.department_id 'department',
   a.num_emp '%_employees',
   a.sal_sum '%_salary'
from
(select department_id, num_emp, employees.*
   from employees
   group by department_id) a,
(select total_count
   from employees) b
order by a.department_id>>  OK
<<select * from sales partition (sales_q2_2000) s
   where s.amount_sold = 1500
   order by cust_id, time_id, channel_id>>  OK
<<select channel_desc, calendar_month_desc, co.country_id, sales
   from sales, customers, times, channels, countries co
   where sales.time_id=times.time_id
  group by grouping sets(
      (channel_desc, calendar_month_desc, co.country_id),
      (channel_desc, co.country_id),
      (calendar_month_desc, co.country_id) )>>  OK
<<select last_name, employee_id, manager_id from employees
   connect by employee_id = manager_id
   order by last_name >> OK
<<select department_id, salary, salary
   from employees
   group by department_id
   having salary = 5000
   order by department_id>> OK
<<select department_id, manager_id
   from employees
   group by department_id, manager_id
   having  department_id = 1
   order by department_id>> OK
<<select *
   from employees
   where job_id = 'pu_clerk'
   order by salary desc>> OK
<<select last_name, department_id, salary
   from employees
   order by department_id asc, salary desc, last_name>>  OK
<<select last_name, department_id, salary
   from employees
   order by 2 asc, 3 desc, 1>> OK
<<select country_name country,
         prod_name prod,
         calendar_year year,
         amount_sold sale,
         amount_sold cnt
    from sales,times,customers,countries,products
    where sales.time_id = times.time_id
    group by country_name,prod_name,calendar_year>> OK
<<select country,prod,year,s
  from sales_view_ref
  model
    partition by (country)
    dimension by (prod, year)
    measures (sale s)
    ignore nav
    unique dimension
    rules upsert sequential order
    (
      s[prod='mouse pad'] = 1,
      s['standard mouse'] = 2
    )
  order by country, prod, year>>  OK
<<select country, year, sale, csum
   from
   (select country, year, salex sale
    from sales_view_ref
    group by country, year
   )
   model dimension by (country, year)
         measures (sale, 0 csum)
         rules
            (
              s['standard mouse'] = 2
            )
   order by country, year>>  OK
<<select e.employee_id, e.salary, e.commission_pct
   from employees e, departments d
   where job_id = 'sa_rep'
   for update
   order by e.employee_id>>  OK
<<select e.employee_id, e.salary, e.commission_pct
   from employees e join departments d
   using (department_id)
   where job_id = 'sa_rep'
   for update of e.salary
   order by e.employee_id>>  OK
<<select * from tablexx
pivot
(xxx(order_total) for order_mode in ('direct' as store, 'online' as internet))>>  OK
<<select * from
(select year, order_mode, order_total from orders)
pivot
(yyy(order_total) for order_mode in ('direct' as store, 'online' as internet))>>  OK
<<select * from pivot_table
  unpivot (yearly_total for order_mode in (store as 'direct', internet as 'online'))
  order by year, order_mode>>  OK
<<select * from pivot_table
  unpivot include nulls
    (yearly_total for order_mode in (store as 'direct', internet as 'online'))
  order by year, order_mode>>  OK
<<select last_name, job_id, departments.department_id, department_name
   from employees, departments
   where employees.department_id = departments.department_id
   order by last_name, job_id>>  OK
<<select last_name, job_id, departments.department_id, department_name
   from employees, departments
   where employees.department_id = departments.department_id
   order by last_name>> OK
<<select last_name, department_id from employees
   where department_id =
     (select department_id from employees
      where last_name = 'lorentz')
   order by last_name, department_id>>  OK
<<select e1.last_name||' works for '||e2.last_name
   'employees and their managers'
   from employees e1, employees e2
   where e1.manager_id = e2.employee_id
   order by e1.last_name>>  OK
<<select d.department_id, e.last_name
   from departments d left outer join employees e
   on d.department_id = e.department_id
   order by d.department_id, e.last_name>>  OK
<<select d.department_id, e.last_name
   from departments d right outer join employees e
   on d.department_id = e.department_id
   order by d.department_id, e.last_name>>  OK
<<select d.department_id as d_dept_id, e.department_id as e_dept_id,
      e.last_name
   from departments d full outer join employees e
     on d.department_id = e.department_id
   order by d.department_id, e.last_name>>  OK
<<select department_id as d_e_dept_id, e.last_name
   from departments d full outer join employees e
   using (department_id)
   order by department_id, e.last_name>>  OK
<<select times.time_id, product, quantity from inventory
   partition by  (product)
   right outer join times on (times.time_id = inventory.time_id)
   where times.time_id = 1
   order by  2,1>> OK
<<select time_id, product, quantity
   from ( select times.time_id, product, quantity
             from inventory partition by  (product)
                right outer join times on (times.time_id = inventory.time_id)
   where times.time_id = 1)
   order by  2,1>> OK
<<select t1.department_id, t2.* from hr_info t1, table(t1.people) t2
   where t2.department_id = t1.department_id>>  OK
<<select last_name org_chart, employee_id, manager_id, job_id
    from employees
    start with job_id = 'ad_vp'
    connect by prior employee_id = manager_id>> OK
<<select last_name, department_name
   from employees@remote, departments
   where employees.department_id = departments.department_id>>  OK
"select sysdate from dual" OK
"select employees_seq.currval from dual" OK

table_ref:
"tablex" OK
<<departments d left outer join employees e
   on d.department_id = e.department_id>>  OK
<<departments d right outer join employees e
   on d.department_id = e.department_id>> OK
<<departments d full outer join employees e
   using (department_id)>>  OK
<<inventory
   partition by  (product)
   right outer join times on (times.time_id = inventory.time_id)>> OK

table_ref_list:
"hr_info t1, table(t1.people) t2 " OK

dml_table_expression_clause:
"tablex" OK

tableview_name:
"sales partition (sales_q2_2000)" OK

table_ref_aux:
"only ( tablex ) " OK
"sales partition (sales_q2_2000)" OK
"orders sample (10)" OK
"orders sample(10) seed (1)" OK
"employees as of timestamp systimestamp" OK
<<employees
  versions between timestamp
    systimestamp and systimestamp2>> OK
"employees e"  OK
"employees as e"  OK
<<employees
  versions between timestamp
    systimestamp and systimestamp2 as e>> OK
<<employees
  versions between timestamp
    systimestamp and systimestamp2 e>> OK


tableview_name:
"tablex" OK


select_statement:
"select*from table_1" OK
"select * from table_1, table2 where table_1.column1=table_2.column2" OK
"select*from table_1 natural inner join table_2" OK
"select*from table_1 inner join table_2 on table_1.column1=table_2.column2" OK
"select*from table_1 left join table_2 on table_1.column1=table_2.column2" OK
"select*from table_1 left outer join table_2 on table_1.column1=table_2.column2" OK
"select*from table_1 full outer join table_2 on table_1.column1=table_2.column2" OK
"select*from table_1 right join table_2 using (id1,id2)" OK

"select*from table_1 union select*from table_2" OK
"select*from table_1 union all select*from table_2"  OK
"select a,b,c from table_1 minus select e,f,g from table_2" OK
<<select a,b,c from table_1
 union all
select e,f,g from table_2
 intersect
select*from table_3
 union
select*from table_4>>
    OK
"select a,b into :VarA,:FrmA.FieldB,: _WIN12503 cc from table_1" OK

"select A from (select B from (select C from d) cross join table_b b)" OK
"select 0 from (select B from (select * from C) cross join table_b as b)" OK

"select * from a where a<> : Var1" OK
"select * from b where a<=:frmF1.clsC1.dfDF1.instI1 --EXF4" OK
"select*from c where a>aa" OK

insert_statement:
"insert into departments
   values (280, 'recreation', 121, 1700)"  OK
<<insert into employees (employee_id, last_name, email,
      hire_date, job_id, salary, commission_pct)
   values (207, 'gregory', 'pgregory@example.com',
      sysdate, 'pu_clerk', 1.2e3, null)>>  OK
<<insert into
   (select employee_id.* from employees)
   values (207, 'gregory', 'pgregory@example.com',
      sysdate, 'pu_clerk', 1.2e3, null)>>  OK
<<insert into bonuses
   select employee_id.* from employees>>  OK
<<insert into raises
   select salary.* from employees
   where commission_pct > .2
   log errors into errlog ('my_bad') reject limit 10>>  OK
<<insert into employees@remote
   values (8002, 'juan', 'fernandez', 'juanf@hr.example.com', null,
   to_date('04-oct-1992', 'dd-mon-yyyy'), 'sh_clerk', 3000,
   null, 121, 20)>>  OK
<<insert into departments
   values  (departments_seq.nextval, 'entertainment', 162, 1400)>>  OK
<<insert into employees
      (employee_id, last_name, email, hire_date, job_id, salary)
   values
   (employees_seq, 'doe', 'john.doe@example.com',
       sysdate, 'sh_clerk', 2400)
   returning salary, job_id into :bnd1, :bnd2>>  OK
<<insert into books values (
   'an autobiography', person_t('bob', 1234))>>  OK
<<insert into lob_tab
   select salary.* from employees>>  OK
<<insert all
      into sales (prod_id, cust_id, time_id, amount)
      values (product_id, customer_id, weekly_start_date, sales_sun)
      into sales (prod_id, cust_id, time_id, amount)
      values (product_id, customer_id, weekly_start_date, sales_mon)
      into sales (prod_id, cust_id, time_id, amount)
      values (product_id, customer_id, weekly_start_date, sales_tue)
      into sales (prod_id, cust_id, time_id, amount)
      values (product_id, customer_id, weekly_start_date, sales_wed)
      into sales (prod_id, cust_id, time_id, amount)
      values (product_id, customer_id, weekly_start_date, sales_thu)
     into sales (prod_id, cust_id, time_id, amount)
      values (product_id, customer_id, weekly_start_date, sales_fri)
      into sales (prod_id, cust_id, time_id, amount)
      values (product_id, customer_id, weekly_start_date, sales_sat)
   select sales_input_table.*
      from sales_input_table>>  OK
<<insert all
   when order_total < 1000000 then
      into small_orders
   when order_total < 2000000 then
      into medium_orders
   when order_total > 2000000 then
      into large_orders
   select orders.* from orders>>  OK
<<insert all
   when order_total < 100000 then
      into small_orders
   when order_total < 200000 then
      into medium_orders
   else
      into large_orders
   select orders.* from orders>>  OK
<<insert all
   when ottl < 100000 then
      into small_orders
         values(oid, ottl, sid, cid)
   when ottl > 100000 and ottl < 200000 then
      into medium_orders
         values(oid, ottl, sid, cid)
   when ottl > 200000 then
      into large_orders
         values(oid, ottl, sid, cid)
   when ottl > 290000 then
      into special_orders
   select o.* from orders o>>  OK
<<insert all
   when ottl < 100000 then
      into small_orders
         values(oid, ottl, sid, cid)
   when ottl > 100000 and ottl < 200000 then
      into medium_orders
         values(oid, ottl, sid, cid)
   when ottl > 200000 then
      into large_orders
         values(oid, ottl, sid, cid)
   when ottl > 290000 then
      into special_orders
   when ottl > 200000 then
      into large_orders
         values(oid, ottl, sid, cid)
   select o.* from orders o>>  OK

delete_statement:
<<delete from product_descriptions
   where language_id = 'ar'>>  OK
<<delete from employees
   where job_id = 'sa_rep'
   and commission_pct < .2>>  OK
<<delete from (select employees.* from employees)
   where job_id = 'sa_rep'
   and commission_pct < .2>>  OK
<<delete from hr.locations@remote
   where location_id > 3000>>  OK
<<delete from sales partition (sales_q1_1998)
   where amount_sold > 1000>>  OK
<<delete from employees
   where job_id = 'sa_rep'
   and hire_date < 10
   returning salary into :bnd1>>  OK

update_statement:
<<update employees
   set commission_pct = null
   where job_id = 'sh_clerk'>>  OK
<<update employees set
    job_id = 'sa_man', salary = 1000, department_id = 120
    where first_name = 'douglas grant'>>  OK
<<update employees@remote
   set salary = 1.1
   where last_name = 'baer'>>  OK
<<update employees a
    set department_id =
        (select departments.*
            from departments
            where location_id = '2100'),
        (salary, commission_pct) =
        (select departments.*
            from departments
            where location_id = '2100')
    where department_id > 1>>  OK
<<update sales partition (sales_q1_1999) s
   set s.promo_id = 494
   where amount_sold > 1000>>  OK
<<update people_demo1 p set value(p) =
   (select departments.* from departments)
   where p.department_id = 10>>  OK
<<update employees
  set job_id ='sa_man', salary = 1000, department_id = 140
  where last_name = 'jones'
  returning salary, last_name, department_id into :bnd1, :bnd2, :bnd3>>  OK
<<update employees
   set salary = 1.1
   where department_id = 100
   returning salary into :bnd1>>  OK
<<update employees
   set salary = 1.1
   where current of c1>>  OK

expression:
"x( a , s, s)" OK
"x( name => a , s, s)" OK
"avg( name => 'a' , s, s)" OK
"x( 'a' , s, s)" OK
<<x( "a" , s, s)>> OK
<<a.b.c.x( "a" , s, s)>> OK
<<a.b().x( a=>11, 22).c.x( "a" , s, s)>> OK

assignment_statement:
<<appraisal :=
   case grade
     when 'a' then 'excellent'
     when 'b' then 'very good'
     when 'c' then 'good'
     when 'd' then 'fair'
     when 'f' then 'poor'
     else 'no such grade'
   end>> OK

<<appraisal :=
   case
     when attends_this_school(id) = false
       then 'student not enrolled'
     when grade = 'f' or attendance < min_days
       then 'poor (poor performance or bad attendance)'
     when grade = 'a' then 'excellent'
     when grade = 'b' then 'very good'
     when grade = 'c' then 'good'
     when grade = 'd' then 'fair'
     else 'no such grade'
   end>>  OK

create_sequence:
"create sequence  a2_ontology_seq;" OK
<<
create sequence  "a2_ontology_seq";
>> OK

drop_sequence:
"drop sequence a2_assaysample_seq;" OK
<<
drop sequence "a2_assaysample_seq";
>> OK

compilation_unit:
<<
create sequence  "a2_ontology_seq";

drop sequence "a2_assaysample_seq";
>> OK

<<
create sequence  "a2_ontology_seq";

create or replace trigger a2_ontology_insert
before insert on a2_ontology
for each row
begin
select a2_ontology_seq.nextval into :new.ontologyid from dual;
end;

alter trigger a2_ontology_insert enable;
>> OK

drop_index:
"drop index p.ix_e;" OK
"drop index ix_e;" OK

create_index:
"create index p.ix_e on p.e (type, edate, tk);" OK
"create index p.ix_e on p.e (type asc, edate asc, tk asc);" OK
"create unique index p.ix_e on p.e (type asc, edate desc, tk);" OK

compilation_unit:
<<
create index p.ix_e on p.e (type, edate, tk);

drop index p.ix_e;
>> OK

